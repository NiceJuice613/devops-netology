1.)	Какой системный вызов делает команда cd?.
chdir("/tmp")
2.)	Попробуйте использовать команду file на объекты разных типов на файловой системе. Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.

Файл базы типов - /usr/share/misc/magic.mgc
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

3.)	Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе)?

lsof -p 1249

vim      1249 vagrant    4u   REG  253,0    12288  526898/home/vagrant/.tst_bash.swp (deleted)

1249 - PID процесса vim
4 - дескриптор файла , который предварительно удалил.

4.)	Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)??

"Зомби" отличии от "сирот" освобождают ресурсы, но не освобождают запись в таблице процессов. Запись освободиться при вызове wait() родительским процессом. 

5.)	В iovisor BCC есть утилита opensnoop:?
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools.

Не могу поставить пакет bpfcc. Что-то устанавливает, н в итоге всегда пишет что-то либо файлы в директории не найдены, либо такой пакет не установлен.

6.)	Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.

uname()
выписка из мана: 
Part of the utsname information is also accessible  via  /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
7.)	Чем отличается последовательность команд через ; и через && в bash? Например:
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~
Есть ли смысл использовать в bash &&, если применить set -e?

&& - условный оператор
; - разделитель команд
Во втором варианте команда echo выполнится только если успешно завершиться команда test.
Применять оператор "&&" и "set –e" смысла скорее всего нет, так как "set –e" прерывает выполнение при любом ненулевом значении команд, и при возникновении ошибки выполнение команд прекратиться.

8.)	Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?

-e прерывает выполнение исполнения при ошибке любой команды кроме последней в последовательности 
-x вывод трейса простых команд 
-u неустановленные/не заданные параметры и переменные считаются как ошибки, с выводом в stderr текста ошибки и выполнит завершение неинтерактивного вызова
-o pipefail возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0 для успешного выполнения команд.

Больше информации по выводу ошибок . Также завершит сценарий при наличии ошибок, на любом этапе выполнения сценария, кроме последней завершающей команды

9.)	Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

S*(S,S+,Ss,Ssl,Ss+) - Процессы ожидающие завершения 
I*(I,I<) – фоновые процессы ядра
символы здесь это характеристики процессов






